# Copyright (C) 2019-2021, TomTom (http://tomtom.com).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Context of the document being generated."""

import copy
import logging
from collections import defaultdict
from pathlib import Path
from typing import Dict, List, MutableMapping, NamedTuple, Optional, Set, Tuple

from tqdm import tqdm

from ..api_reference import ApiReference
from ..document import Document, Package
from ..model import ReferableElement
from ..packaging import PackageManager, UnknownFileError
from ..path_utils import relative_path
from .errors import ConsistencyError, DuplicateAnchorError, UnknownAnchorError
from .filters import InsertionFilter
from .navigation import DocumentTreeNode

logger = logging.getLogger(__name__)


class Environment(object):
    """Namespace for holding environment variables to be shared between different AsciiDoc files.

    AsciiDoc files can assign variables in the environment namespace to be reused in other AsciiDoc
    files that are included from it. Like other concepts in AsciiDoxy, the changes should only
    apply to the current file, and any include from the current file. The parent namespace should
    remain unchanged.

    This class is intentionaly simple. New variables can be added to an instance by simply
    assigining them:

      env = Environment()
      env.new_var = "value"

    To copy the environment to subcontexts use copy.copy(). This prevents changing the variables
    in the parent scopes.
    """


class StackFrame(NamedTuple):
    """Frame on the stack of AsciiDoxy commands being executed.

    The sequence of stack frames can be used to provide detailed feedback on how a certain action
    has been called. This is especially useful for a chain of actions generated by AsciiDoxy
    itself.

    Attributes:
        command:  Description of the command being executed.
        file:     If applicable, the file from which the command originated. Empty for commands
                      originating from other AsciiDoxy commands.
        package:  If applicable, the package containing the file.
        internal: True if the stack frame is for an internal method call.
    """
    command: str
    file: Optional[Path]
    package: Optional[str]
    internal: bool


def stacktrace(trace: List[StackFrame], prefix: str = "") -> str:
    """Generate a string representation of a sequence of stack frames.

    Args:
        trace:  Sequence of stack frames.
        prefix: Optional prefix for each line. E.g. to add indentation.

    Returns:
        String representation of the stack trace.
    """
    if not trace:
        return ""

    trace = trace[:]
    lines = []

    if not trace[0].internal:
        lines.append(f"{prefix}Commands in input files:")
    while trace and not trace[0].internal:
        if trace[0].package and trace[0].package != Package.INPUT_PACKAGE_NAME:
            pkg = f"{trace[0].package}:/"
        else:
            pkg = ""
        lines.append(f"{prefix}  {pkg}{trace[0].file}:\n{prefix}    {trace[0].command}")
        trace.pop(0)

    if trace and trace[0].internal:
        lines.append(f"{prefix}Internal AsciiDoxy commands:")
    while trace:
        lines.append(f"{prefix}    {trace[0].command}")
        trace.pop(0)

    return "\n".join(lines)


class Context(object):
    """Contextual information about the document being generated.

    This information is meant to be shared with all included documents as well.

    Attributes:
        namespace:             Current namespace to use when looking up references.
        language:              Default language to use when looking up references.
        insert_filter:         Filter used to select members of elements to insert.
        env:                   Environment variables to share with subdocuments.
        warnings_are_errors:   True to treat every warning as an error.
        multipage:             True when multi page output is enabled.
        reference:             API reference information.
        linked:                All elements to which links are inserted in the documentation.
        inserted:              All elements that have been inserted in the documentation.
        anchors:               Mapping from flexible anchors to the containing files.
        in_to_out_file_map:    Mapping from input files for AsciiDoctor to the resulting output
                                   files.
        current_document_node: Node in the Document Tree that is currently being processed.
        current_package:       Package containing the current files.
        call_stack:            Stack of actions resulting in the current action.
    """
    namespace: Optional[str] = None
    language: Optional[str] = None
    source_language: Optional[str] = None
    insert_filter: InsertionFilter
    env: Environment

    warnings_are_errors: bool = False
    multipage: bool = False
    embedded: bool = False

    reference: ApiReference
    package_manager: PackageManager
    progress: Optional[tqdm] = None

    linked: Dict[str, List[List[StackFrame]]]
    # TODO: Use Document
    inserted: MutableMapping[str, Tuple[Path, List[StackFrame]]]
    # TODO: Use DOcument
    anchors: Dict[str, Tuple[Path, Optional[str]]]
    # TODO: Remove
    in_to_out_file_map: Dict[Path, Path]
    # TODO: Remove
    embedded_file_map: Dict[Path, Set[Path]]
    # TODO: Remove
    current_document_node: DocumentTreeNode
    # TODO: Use from document
    current_package: Package
    call_stack: List[StackFrame]

    documents: Dict[Path, Document]

    def __init__(self, reference: ApiReference, package_manager: PackageManager,
                 current_document_node: DocumentTreeNode, current_package: Package):
        self.insert_filter = InsertionFilter(members={"prot": ["+public", "+protected"]})
        self.env = Environment()

        self.reference = reference
        self.package_manager = package_manager

        self.linked = defaultdict(list)
        self.inserted = {}
        self.anchors = {}
        self.in_to_out_file_map = {}
        self.embedded_file_map = defaultdict(set)
        self.current_document_node = current_document_node
        self.current_package = current_package
        self.call_stack = []

        self.documents = {}

    def insert(self, element: ReferableElement) -> None:
        assert element.id
        if element.id in self.inserted:
            _, trace = self.inserted[element.id]
            msg = (f"Duplicate insertion of {element.name}.\nTrying to insert at:\n"
                   f"{stacktrace(self.call_stack, prefix='  ')}\nPreviously inserted at:\n"
                   f"{stacktrace(trace, prefix='  ')}")
            if self.warnings_are_errors:
                raise ConsistencyError(msg)
            else:
                logger.warning(msg)
        self.inserted[element.id] = (self.current_document_node.in_file, self.call_stack[:])

    def sub_context(self) -> "Context":
        sub = Context(reference=self.reference,
                      package_manager=self.package_manager,
                      current_document_node=self.current_document_node,
                      current_package=self.current_package)

        # Copies
        sub.namespace = self.namespace
        sub.language = self.language
        sub.source_language = self.source_language
        sub.warnings_are_errors = self.warnings_are_errors
        sub.multipage = self.multipage
        sub.embedded = self.embedded
        sub.env = copy.copy(self.env)
        sub.insert_filter = copy.deepcopy(self.insert_filter)

        # References
        sub.linked = self.linked
        sub.inserted = self.inserted
        sub.anchors = self.anchors
        sub.in_to_out_file_map = self.in_to_out_file_map
        sub.embedded_file_map = self.embedded_file_map
        sub.progress = self.progress
        sub.call_stack = self.call_stack
        sub.documents = self.documents

        return sub

    def file_with_element(self, element_id: str) -> Optional[Path]:
        if not self.multipage or element_id not in self.inserted:
            return None

        containing_file = self.inserted[element_id][0]
        assert containing_file is not None
        if self.current_document_node.in_file != containing_file:
            return containing_file
        else:
            return None

    def link_to_element(self, element_id: str) -> None:
        self.linked[element_id].append(self.call_stack[:])

    def find_document(self, package_name: Optional[str], rel_path: Optional[Path]) -> Document:
        # TODO: Deduplicate and optimize
        assert package_name or rel_path

        if rel_path is None:
            default_doc = self.package_manager.make_document(package_name)
            known_doc = self.documents.get(default_doc.relative_path)
            if known_doc is None:
                self.documents[default_doc.relative_path] = default_doc
                return default_doc
            return known_doc

        else:

            known_doc = self.documents.get(rel_path)
            if known_doc is None:
                doc = self.package_manager.make_document(package_name, rel_path)
                self.documents[doc.relative_path] = doc
                return doc
            elif package_name and known_doc.package.name != package_name:
                raise UnknownFileError(package_name, str(rel_path))
            return known_doc

    def register_adoc_file(self, in_file: Path) -> Path:
        assert in_file.is_absolute()
        if self.embedded:
            out_file = self.current_document_node.in_file
            self.embedded_file_map[in_file].add(out_file)
        else:
            known_out_file = self.in_to_out_file_map.get(in_file)

            if known_out_file is None:
                out_file = _out_file_name(in_file)
                self.in_to_out_file_map[in_file] = out_file
            else:
                out_file = known_out_file

        return out_file

    def link_to_adoc_file(self, file_name: Path) -> Path:
        """Determine the correct path to link to a file.

        The exact path differs for single and multipage mode and whether a file is embedded or not.
        AsciiDoctor processes links in included files as if they are originating from the top level
        file.
        """
        assert file_name.is_absolute()

        if self.multipage:
            embedded_files = self.embedded_file_map.get(file_name)
            if embedded_files is not None:
                if len(embedded_files) == 1:
                    # File is only embedded in one file, link to that file
                    return relative_path(self.current_document_node.in_file,
                                         list(embedded_files)[0])
                else:
                    # File is embedded multiple time, can only link if it is embedded in the
                    # current document
                    if self.current_document_node.in_file in embedded_files:
                        return Path(self.current_document_node.in_file.name)
                    else:
                        raise ConsistencyError("Cannot resolve link to embedded file: The same file"
                                               " is embedded multiple times. Either embed the file"
                                               " in only one file, or only link to it from the"
                                               " files it is embedded in.")
            else:
                # File is not embedded, link to original file name
                return relative_path(self.current_document_node.in_file, file_name)

        else:
            # In singlepage mode all links need to be relative to the root file
            embedded_files = self.embedded_file_map.get(file_name)
            if embedded_files is not None:
                if len(embedded_files) == 1:
                    # File is only embedded in one file, link to that file
                    return relative_path(self.current_document_node.root().in_file,
                                         list(embedded_files)[0])
                else:
                    # File is embedded multiple time, can only link if it is embedded in the
                    # current document
                    if self.current_document_node.in_file in embedded_files:
                        return relative_path(self.current_document_node.root().in_file,
                                             self.current_document_node.in_file)
                    else:
                        raise ConsistencyError("Cannot resolve link to embedded file: The same file"
                                               " is embedded multiple times. Either embed the file"
                                               " in only one file, or only link to it from the"
                                               " files it is embedded in.")

            out_file = self.in_to_out_file_map.get(file_name, None)
            if out_file is not None:
                # File has been processed, and as we are in single page mode, it is embedded as
                # well
                return relative_path(self.current_document_node.root().in_file, out_file)

            else:
                # File is not processed, create relative link from current top level document
                return relative_path(self.current_document_node.root().in_file, file_name)

    def docinfo_footer_file(self) -> Path:
        if self.multipage:
            in_file = self.current_document_node.in_file
        else:
            in_file = self.current_document_node.root().in_file

        out_file = self.in_to_out_file_map.get(in_file, None)
        if out_file is None:
            out_file = _out_file_name(in_file)

        return _docinfo_footer_file_name(out_file)

    def register_anchor(self, name: str, link_text: Optional[str], file_name: Path) -> None:
        if name in self.anchors:
            raise DuplicateAnchorError(name)
        self.anchors[name] = file_name, link_text

    def link_to_anchor(self, name: str) -> Tuple[Path, Optional[str]]:
        file_name, link_text = self.anchors.get(name, (None, None))
        if file_name is None:
            raise UnknownAnchorError(name)
        return self.link_to_adoc_file(file_name), link_text

    def push_stack(self,
                   command: str,
                   file: Optional[Path] = None,
                   package: Optional[str] = None,
                   internal: bool = False) -> None:
        self.call_stack.append(StackFrame(command, file, package, internal))

    def pop_stack(self) -> None:
        self.call_stack.pop(-1)


def _out_file_name(in_file: Path) -> Path:
    return in_file.parent / f".asciidoxy.{in_file.name}"


def _docinfo_footer_file_name(out_file: Path) -> Path:
    return out_file.parent / f"{out_file.stem}-docinfo-footer.html"
